 
package plugins

// this file is automatically generated

import (
  "github.com/pkg/errors"
	"github.com/bytesparadise/libasciidoc/pkg/types"

  log "github.com/sirupsen/logrus"
)

func wrapToCSection(obj *types.ToCSection) Wrap {
  log.Trace("Wrapping a ToCSection")

  // add type
  wrapped := Wrap {
    Type: "ToCSection",
    Value: nil,
  }

  // return nil values
  if obj == nil {
    return wrapped
  }

  // wrap non-atomic parts and store atoms
  wrapped.Value = map[string]interface{}{
  
    "id": obj.ID,
  
    "level": obj.Level,
  
    "title": obj.Title,
  
    "children": wrap(obj.Children),
  
  }

  return wrapped
}

func unwrapToCSection(value interface{}) (*types.ToCSection, error) {
  log.Trace("Unwrapping a ToCSection")

  // if it's nil, just return a nil of its type
  if value == nil {
    log.Trace("ToCSection is nil")
    return (*types.ToCSection)(nil), nil
  }

  // make sure all parts are present
  objMap, ok := value.(map[string]interface{})
  if ! ok {
    return nil, errors.New("'ToCSection' type not map[string]interface{}")
  }
  
    id, ok := objMap["id"]
    if ! ok {
      return nil, errors.New("ToCSection does not contain 'id'")
    }
  
    level, ok := objMap["level"]
    if ! ok {
      return nil, errors.New("ToCSection does not contain 'level'")
    }
  
    title, ok := objMap["title"]
    if ! ok {
      return nil, errors.New("ToCSection does not contain 'title'")
    }
  
    children, ok := objMap["children"]
    if ! ok {
      return nil, errors.New("ToCSection does not contain 'children'")
    }
  

  // unwrap non-atomic parts
  var err error
  
    
  
    
  
    
  
    
      log.Trace("Unwrapping ToCSection children")
      children, err = unwrap(children)
      if err != nil {
        return nil, err
      }
    
  

  // assert the types of the parts
  
    
      assertedID, ok := id.(string)
      if ! ok {
        return nil, errors.New("ToCSection ID is not type string")
      }
    
  
    
      // ints come back as float64 in JSON, convert them
      floatLevel, ok := level.(float64)
      if ! ok {
        return nil, errors.New("ToCSection Level is not type float64")
      }
      assertedLevel := int(floatLevel)
    
  
    
      assertedTitle, ok := title.(string)
      if ! ok {
        return nil, errors.New("ToCSection Title is not type string")
      }
    
  
    
      assertedChildren, ok := children.([]*types.ToCSection)
      if ! ok {
        return nil, errors.New("ToCSection Children is not type []*types.ToCSection")
      }
    
  

  // build object
  return &types.ToCSection{
    ID: assertedID,
    Level: assertedLevel,
    Title: assertedTitle,
    Children: assertedChildren,
  }, nil
}
