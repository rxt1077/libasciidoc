// +build wrap

package main

import (
  "os"
  "text/template"
  "strings"
  "fmt"
)

type fieldInfo struct {
  Type string
  Name string
  JSName string
  IsAtom bool
}

type dataForStruct struct {
  Type string
  Name string
  Fields []fieldInfo
}

func main() {
// TODO: Structure has changed! Revise these:
/*  data := dataForStruct{
  data := dataForStruct{
    TypeName: "QuotedString",
    Type: "*types.QuotedString",
    Fields: []fieldInfo{
      fieldInfo{"Kind", "kind", "kind", true, "types.QuotedStringKind"},
      fieldInfo{"Elements", "elements", "elements", true, "[]interface{}"},
    },
  }*/
  structures := []dataForStruct{
    // AttributeDeclaration requires manual tweaking due to unexported 'rawText'
    /*{"*types.AttributeDeclaration", "AttributeDeclaration", []fieldInfo{
      {"string", "Name", "name", true},
      {"interface{}", "Value", "value", false},
      {"string", "rawText", "rawText", true}}}, */
    {"*types.DelimitedBlock", "DelimitedBlock", []fieldInfo{
      {"string", "Kind", "kind", true},
      {"types.Attributes", "Attributes", "attributes", false},
      {"[]interface{}", "Elements", "elements", false}}},
    {"*types.InlineImage", "InlineImage", []fieldInfo{
      {"*types.Location", "Location", "location", false},
      {"types.Attributes", "Attributes", "attributes", false}}},
    /*{"*types.InternalCrossReference", "InternalCrossReference", []fieldInfo{
      {"interface{}", "ID", "id", false},
      {"interface{}", "Label", "label", false}}}, */
    {"*types.OrderedListElement", "OrderedListElement", []fieldInfo{
      {"types.Attributes", "Attributes", "attributes", false},
      {"string", "Style", "style", true},
      {"[]interface{}", "Elements", "elements", false}}},
    {"*types.Preamble", "Preamble", []fieldInfo{
      {"[]interface{}", "Elements", "elements", false},
      {"*types.TableOfContents", "TableOfContents", "tableOfContents", false}}},
    {"*types.ToCSection", "ToCSection", []fieldInfo{
      {"string", "ID", "id", true},
      {"int", "Level", "level", true},
      {"string", "Title", "title", true},
      {"[]*types.ToCSection", "Children", "children", false}}},
  }

  tmpl := template.Must(template.New("struct").Parse(structTemplate))
  for _, data := range structures {
    fileName := "wrap_" + strings.ToLower(data.Name) + ".go"
    fmt.Printf("Generating %s\n", fileName)
    file, _ := os.Create(fileName)
    tmpl.Execute(file, data)
    file.Close()
  }
}

var structTemplate = ` 
package plugins

// this file is automatically generated

import (
  "github.com/pkg/errors"
	"github.com/bytesparadise/libasciidoc/pkg/types"

  log "github.com/sirupsen/logrus"
)

func wrap{{.Name}}(obj {{.Type}}) Wrap {
  log.Trace("Wrapping a {{.Name}}")

  // add type
  wrapped := Wrap {
    Type: "{{.Name}}",
    Value: nil,
  }

  // return nil values
  if obj == nil {
    return wrapped
  }

  // wrap non-atomic parts and store atoms
  wrapped.Value = map[string]interface{}{
  {{range $index, $element := .Fields}}
    "{{$element.JSName}}": {{if $element.IsAtom}}obj.{{$element.Name}}{{else}}wrap(obj.{{$element.Name}}){{end}},
  {{end}}
  }

  return wrapped
}

func unwrap{{.Name}}(value interface{}) ({{.Type}}, error) {
  log.Trace("Unwrapping a {{.Name}}")

  // if it's nil, just return a nil of its type
  if value == nil {
    log.Trace("{{.Name}} is nil")
    return ({{.Type}})(nil), nil
  }

  // make sure all parts are present
  objMap, ok := value.(map[string]interface{})
  if ! ok {
    return nil, errors.New("'{{.Name}}' type not map[string]interface{}")
  }
  {{range $index, $element := .Fields}}
    {{ $element.JSName }}, ok := objMap["{{ $element.JSName }}"]
    if ! ok {
      return nil, errors.New("{{$.Name}} does not contain '{{$element.JSName}}'")
    }
  {{end}}

  // unwrap non-atomic parts
  var err error
  {{range $index, $element := .Fields}}
    {{if not $element.IsAtom}}
      log.Trace("Unwrapping {{$.Name}} {{$element.JSName}}")
      {{$element.JSName}}, err = unwrap({{$element.JSName}})
      if err != nil {
        return nil, err
      }
    {{end}}
  {{end}}

  // assert the types of the parts
  {{range $index, $element := .Fields}}
    {{if eq $element.Type "int"}}
      // ints come back as float64 in JSON, convert them
      float{{$element.Name}}, ok := {{$element.JSName}}.(float64)
      if ! ok {
        return nil, errors.New("{{$.Name}} {{$element.Name}} is not type float64")
      }
      asserted{{$element.Name}} := int(float{{$element.Name}})
    {{else}}
      asserted{{$element.Name}}, ok := {{$element.JSName}}.({{$element.Type}})
      if ! ok {
        return nil, errors.New("{{$.Name}} {{$element.Name}} is not type {{$element.Type}}")
      }
    {{end}}
  {{end}}

  // build object
  return &types.{{.Name}}{
    {{- range $index, $element := .Fields}}
    {{$element.Name}}: asserted{{$element.Name}},
    {{- end}}
  }, nil
}
`
